/* 
 * Copyright (C) 2025 Seth McDonald
 * 
 * This file is part of Collatz Conjecture Simulator.
 * 
 * Collatz Conjecture Simulator is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 * 
 * Collatz Conjecture Simulator is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with Collatz Conjecture
 * Simulator. If not, see <https://www.gnu.org/licenses/>.
 */

#include "wrap_win32.h"
#include "debug.h"
#include "util.h"

#if CZ_WRAP_RECALLOC
enum CzResult czWrap_recalloc(void* restrict* res, void* memblock, size_t num, size_t size)
{
	void* p = _recalloc(memblock, num, size);
	if CZ_EXPECT (p) {
		*res = p;
		return CZ_RESULT_SUCCESS;
	}

	double t = program_time();
	log_error(
		stderr, "_recalloc failed with memblock 0x%016" PRIxPTR ", num %zu, size %zu (%.3fms)",
		(uintptr_t) memblock, num, size, t);

	int err;
	_get_errno(&err);

	switch (err) {
	case ENOMEM:
		return CZ_RESULT_NO_MEMORY;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_ALIGNED_OFFSET_MALLOC
enum CzResult czWrap_aligned_offset_malloc(void* restrict* res, size_t size, size_t alignment, size_t offset)
{
	void* p = _aligned_offset_malloc(size, alignment, offset);
	if CZ_EXPECT (p) {
		*res = p;
		return CZ_RESULT_SUCCESS;
	}

	double t = program_time();
	log_error(
		stderr, "_aligned_offset_malloc failed with size %zu, alignment %zu, offset %zu (%.3fms)",
		size, alignment, offset, t);

	int err;
	_get_errno(&err);

	switch (err) {
	case EINVAL:
		if (!alignment)
			return CZ_RESULT_BAD_ALIGNMENT;
		if (alignment & (alignment - 1))
			return CZ_RESULT_BAD_ALIGNMENT;
		return CZ_RESULT_BAD_OFFSET;
	case ENOMEM:
		return CZ_RESULT_NO_MEMORY;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_ALIGNED_OFFSET_REALLOC
enum CzResult czWrap_aligned_offset_realloc(
	void* restrict* res, void* memblock, size_t size, size_t alignment, size_t offset)
{
	void* p = _aligned_offset_realloc(memblock, size, alignment, offset);
	if CZ_EXPECT (p) {
		*res = p;
		return CZ_RESULT_SUCCESS;
	}

	double t = program_time();
	log_error(
		stderr,
		"_aligned_offset_realloc failed with memblock 0x%016" PRIxPTR ", size %zu, alignment %zu, offset %zu (%.3fms)",
		(uintptr_t) memblock, size, alignment, offset, t);

	int err;
	_get_errno(&err);

	switch (err) {
	case EINVAL:
		if (!alignment)
			return CZ_RESULT_BAD_ALIGNMENT;
		if (alignment & (alignment - 1))
			return CZ_RESULT_BAD_ALIGNMENT;
		return CZ_RESULT_BAD_OFFSET;
	case ENOMEM:
		return CZ_RESULT_NO_MEMORY;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_ALIGNED_OFFSET_RECALLOC
enum CzResult czWrap_aligned_offset_recalloc(
	void* restrict* res, void* memblock, size_t num, size_t size, size_t alignment, size_t offset)
{
	void* p = _aligned_offset_recalloc(memblock, num, size, alignment, offset);
	if CZ_EXPECT (p) {
		*res = p;
		return CZ_RESULT_SUCCESS;
	}

	double t = program_time();
	log_error(
		stderr,
		"_aligned_offset_recalloc failed with "
		"memblock 0x%016" PRIxPTR ", num %zu, size %zu, alignment %zu, offset %zu (%.3fms)",
		(uintptr_t) memblock, num, size, alignment, offset, t);

	int err;
	_get_errno(&err);

	switch (err) {
	case EINVAL:
		if (!alignment)
			return CZ_RESULT_BAD_ALIGNMENT;
		if (alignment & (alignment - 1))
			return CZ_RESULT_BAD_ALIGNMENT;
		return CZ_RESULT_BAD_OFFSET;
	case ENOMEM:
		return CZ_RESULT_NO_MEMORY;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_GET_OSFHANDLE
enum CzResult czWrap_get_osfhandle(intptr_t* res, int fd)
{
	intptr_t h = _get_osfhandle(fd);
	if CZ_EXPECT (h != INVALID_HANDLE_VALUE) {
		*res = h;
		return CZ_RESULT_SUCCESS;
	}

	int err;
	_get_errno(&err);

	switch (err) {
	case EBADF:
		return CZ_RESULT_BAD_ACCESS;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_MULTI_BYTE_TO_WIDE_CHAR
enum CzResult czWrap_MultiByteToWideChar(
	LPINT res,
	UINT CodePage,
	DWORD dwFlags,
	LPCCH lpMultiByteStr,
	INT cbMultiByte,
	LPWSTR lpWideCharStr,
	INT cchWideChar)
{
	INT r = MultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
	if (res)
		*res = r;
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_INVALID_FLAGS:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INSUFFICIENT_BUFFER:
		if (!lpMultiByteStr)
			return CZ_RESULT_BAD_ADDRESS;
		if (!lpWideCharStr)
			return CZ_RESULT_BAD_ADDRESS;
		return CZ_RESULT_BAD_SIZE;
	case ERROR_INVALID_PARAMETER:
		if (lpMultiByteStr == lpWideCharStr)
			return CZ_RESULT_BAD_ADDRESS;
		if (!cbMultiByte)
			return CZ_RESULT_BAD_SIZE;
		if (cbMultiByte < -1)
			return CZ_RESULT_BAD_SIZE;
		if (cchWideChar < 0)
			return CZ_RESULT_BAD_SIZE;
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_NO_UNICODE_TRANSLATION:
		return CZ_RESULT_BAD_PATH;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_GET_FILE_ATTRIBUTES_EX_W
enum CzResult czWrap_GetFileAttributesExW(
	LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
{
	BOOL r = GetFileAttributesExW(lpFileName, fInfoLevelId, lpFileInformation);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_DYNLINK_FROM_INVALID_RING:
	case ERROR_FORMS_AUTH_REQUIRED:
	case ERROR_NETWORK_ACCESS_DENIED:
	case ERROR_WRITE_PROTECT:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_ALREADY_ASSIGNED:
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_EA_HANDLE:
	case ERROR_INVALID_EA_NAME:
	case ERROR_NO_MORE_ITEMS:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BAD_ARGUMENTS:
	case ERROR_BAD_DEVICE_PATH:
	case ERROR_BAD_NET_NAME:
	case ERROR_BAD_PATHNAME:
	case ERROR_BUFFER_OVERFLOW:
	case ERROR_DIR_NOT_ROOT:
	case ERROR_DIRECTORY:
	case ERROR_FILENAME_EXCED_RANGE:
	case ERROR_INVALID_DATA:
	case ERROR_INVALID_DRIVE:
	case ERROR_INVALID_FIELD_IN_PARAMETER_LIST:
	case ERROR_INVALID_NAME:
	case ERROR_INVALID_PARAMETER:
	case ERROR_LABEL_TOO_LONG:
	case ERROR_META_EXPANSION_TOO_LONG:
	case ERROR_PATH_NOT_FOUND:
	case ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME:
		return CZ_RESULT_BAD_PATH;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PATH_BUSY:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_BAD_NETPATH:
	case ERROR_BAD_UNIT:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_FILE_NOT_FOUND:
	case ERROR_MOD_NOT_FOUND:
	case ERROR_NETNAME_DELETED:
	case ERROR_PROC_NOT_FOUND:
		return CZ_RESULT_NO_FILE;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_GET_FILE_INFORMATION_BY_HANDLE_EX
enum CzResult czWrap_GetFileInformationByHandleEx(
	HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
{
	BOOL r = GetFileInformationByHandleEx(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_DATA:
	case ERROR_NO_MORE_ITEMS:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	case ERROR_HANDLE_EOF:
		switch (FileInformationClass) {
		case FileStreamInfo:
			if (dwBufferSize >= sizeof(FILE_STREAM_INFO))
				((PFILE_STREAM_INFO) lpFileInformation)->NextEntryOffset = 0;
			return CZ_RESULT_SUCCESS;
		default:
			return CZ_RESULT_INTERNAL_ERROR;
		}
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_SET_FILE_INFORMATION_BY_HANDLE
enum CzResult czWrap_SetFileInformationByHandle(
	HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
{
	BOOL r = SetFileInformationByHandle(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_DATA:
	case ERROR_NO_MORE_ITEMS:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_GET_FILE_SIZE_EX
enum CzResult czWrap_GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
{
	BOOL r = GetFileSizeEx(hFile, lpFileSize);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_DATA:
	case ERROR_NO_MORE_ITEMS:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_GET_FILE_TYPE
enum CzResult czWrap_GetFileType(PDWORD res, HANDLE hFile)
{
	DWORD r = GetFileType(hFile);
	if CZ_EXPECT (r) {
		*res = r;
		return CZ_RESULT_SUCCESS;
	}

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_SUCCESS:
		*res = r;
		return CZ_RESULT_SUCCESS;
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_DATA:
	case ERROR_NO_MORE_ITEMS:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
}
#endif

#if CZ_WRAP_CREATE_FILE_W
enum CzResult czWrap_CreateFileW(
	LPHANDLE res,
	LPCWSTR lpFileName,
	DWORD dwDesiredAccess,
	DWORD dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	DWORD dwCreationDisposition,
	DWORD dwFlagsAndAttributes,
	HANDLE hTemplateFile)
{
	HANDLE h = CreateFileW(
		lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes,
		hTemplateFile);

	if CZ_EXPECT (h != INVALID_HANDLE_VALUE) {
		*res = h;
		return CZ_RESULT_SUCCESS;
	}

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_DYNLINK_FROM_INVALID_RING:
	case ERROR_FORMS_AUTH_REQUIRED:
	case ERROR_NETWORK_ACCESS_DENIED:
	case ERROR_READ_FAULT:
	case ERROR_WRITE_FAULT:
	case ERROR_WRITE_PROTECT:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_ALREADY_ASSIGNED:
	case ERROR_ALREADY_EXISTS:
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_CURRENT_DIRECTORY:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DIR_NOT_EMPTY:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_EXISTS:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_EA_HANDLE:
	case ERROR_INVALID_EA_NAME:
	case ERROR_NO_MORE_ITEMS:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_OPEN_FAILED:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_SEEK_ON_DEVICE:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_CANNOT_MAKE:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_OPEN_FAILED:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BAD_ARGUMENTS:
	case ERROR_BAD_DEVICE_PATH:
	case ERROR_BAD_NET_NAME:
	case ERROR_BAD_PATHNAME:
	case ERROR_BUFFER_OVERFLOW:
	case ERROR_DIR_NOT_ROOT:
	case ERROR_DIRECTORY:
	case ERROR_FILENAME_EXCED_RANGE:
	case ERROR_INVALID_DATA:
	case ERROR_INVALID_DRIVE:
	case ERROR_INVALID_FIELD_IN_PARAMETER_LIST:
	case ERROR_INVALID_NAME:
	case ERROR_INVALID_PARAMETER:
	case ERROR_LABEL_TOO_LONG:
	case ERROR_META_EXPANSION_TOO_LONG:
	case ERROR_PATH_NOT_FOUND:
	case ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME:
		return CZ_RESULT_BAD_PATH;
	case ERROR_BUSY:
	case ERROR_DELETE_PENDING:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PATH_BUSY:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_BAD_NETPATH:
	case ERROR_BAD_UNIT:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_FILE_NOT_FOUND:
	case ERROR_HANDLE_EOF:
	case ERROR_MOD_NOT_FOUND:
	case ERROR_NETNAME_DELETED:
	case ERROR_PROC_NOT_FOUND:
		return CZ_RESULT_NO_FILE;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_SHARING_BUFFER_EXCEEDED:
	case ERROR_TOO_MANY_DESCRIPTORS:
	case ERROR_TOO_MANY_MODULES:
	case ERROR_TOO_MANY_OPEN_FILES:
		return CZ_RESULT_NO_OPEN;
	case ERROR_ATOMIC_LOCKS_NOT_SUPPORTED:
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_CLOSE_HANDLE
enum CzResult czWrap_CloseHandle(HANDLE hObject)
{
	BOOL r = CloseHandle(hObject);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCKED:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
		return CZ_RESULT_IN_USE;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_SET_END_OF_FILE
enum CzResult czWrap_SetEndOfFile(HANDLE hFile)
{
	BOOL r = SetEndOfFile(hFile);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_DATA:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_SEEK_ON_DEVICE:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_RANGES_PROCESSED:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_SET_FILE_POINTER_EX
enum CzResult czWrap_SetFilePointerEx(
	HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
{
	BOOL r = SetFilePointerEx(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_ALREADY_ASSIGNED:
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_SEEK_ON_DEVICE:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_BAD_ARGUMENTS:
	case ERROR_HANDLE_EOF:
	case ERROR_INVALID_DATA:
	case ERROR_INVALID_FIELD_IN_PARAMETER_LIST:
	case ERROR_INVALID_PARAMETER:
	case ERROR_NEGATIVE_SEEK:
	case ERROR_OFFSET_ALIGNMENT_VIOLATION:
		return CZ_RESULT_BAD_OFFSET;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_READ_FILE
enum CzResult czWrap_ReadFile(
	HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
{
	BOOL r = ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();

	LARGE_INTEGER posDist = {0};
	LARGE_INTEGER pos;
	BOOL posRes = SetFilePointerEx(hFile, posDist, &pos, FILE_CURRENT);
	DWORD posErr = !posRes ? GetLastError() : ERROR_SUCCESS;
	SetLastError(err);

	switch (err) {
	case ERROR_IO_PENDING:
	case ERROR_MORE_DATA:
		return CZ_RESULT_SUCCESS;
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_ALREADY_ASSIGNED:
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_DATA:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_SEEK_ON_DEVICE:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_RANGES_PROCESSED:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BAD_ARGUMENTS:
	case ERROR_INVALID_FIELD_IN_PARAMETER_LIST:
	case ERROR_INVALID_PARAMETER:
	case ERROR_NEGATIVE_SEEK:
	case ERROR_OFFSET_ALIGNMENT_VIOLATION:
		return CZ_RESULT_BAD_OFFSET;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_OPERATION_ABORTED:
		return CZ_RESULT_INTERRUPT;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_ATOMIC_LOCKS_NOT_SUPPORTED:
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	case ERROR_HANDLE_EOF:
		if (!lpOverlapped && posErr != ERROR_SUCCESS)
			return CZ_RESULT_INTERNAL_ERROR;
		if (!lpOverlapped && pos.QuadPart)
			return CZ_RESULT_BAD_OFFSET;
		if (!lpOverlapped)
			return CZ_RESULT_NO_FILE;
		if (lpOverlapped->Offset)
			return CZ_RESULT_BAD_OFFSET;
		if (lpOverlapped->OffsetHigh)
			return CZ_RESULT_BAD_OFFSET;
		return CZ_RESULT_NO_FILE;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_WRITE_FILE
enum CzResult czWrap_WriteFile(
	HANDLE hFile,
	LPCVOID lpBuffer,
	DWORD nNumberOfBytesToWrite,
	LPDWORD lpNumberOfBytesWritten,
	LPOVERLAPPED lpOverlapped)
{
	BOOL r = WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_IO_PENDING:
		return CZ_RESULT_SUCCESS;
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
	case ERROR_WRITE_PROTECT:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_ALREADY_ASSIGNED:
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_SEEK_ON_DEVICE:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_RANGES_PROCESSED:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BAD_ARGUMENTS:
	case ERROR_INVALID_FIELD_IN_PARAMETER_LIST:
	case ERROR_INVALID_PARAMETER:
	case ERROR_NEGATIVE_SEEK:
	case ERROR_OFFSET_ALIGNMENT_VIOLATION:
		return CZ_RESULT_BAD_OFFSET;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_OPERATION_ABORTED:
		return CZ_RESULT_INTERRUPT;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_ATOMIC_LOCKS_NOT_SUPPORTED:
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_DELETE_FILE_W
enum CzResult czWrap_DeleteFileW(LPCWSTR lpFileName)
{
	BOOL r = DeleteFileW(lpFileName);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_EA_NAME:
	case ERROR_MORE_DATA:
	case ERROR_NO_DATA:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_VC_DISCONNECTED:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BAD_ARGUMENTS:
	case ERROR_BAD_DEVICE_PATH:
	case ERROR_BAD_NET_NAME:
	case ERROR_BAD_PATHNAME:
	case ERROR_BUFFER_OVERFLOW:
	case ERROR_DIR_NOT_ROOT:
	case ERROR_DIRECTORY:
	case ERROR_FILENAME_EXCED_RANGE:
	case ERROR_INVALID_FIELD_IN_PARAMETER_LIST:
	case ERROR_INVALID_NAME:
	case ERROR_INVALID_PARAMETER:
	case ERROR_LABEL_TOO_LONG:
	case ERROR_META_EXPANSION_TOO_LONG:
	case ERROR_PATH_NOT_FOUND:
	case ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME:
		return CZ_RESULT_BAD_PATH;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PATH_BUSY:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_BAD_NETPATH:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_FILE_NOT_FOUND:
	case ERROR_MOD_NOT_FOUND:
	case ERROR_NETNAME_DELETED:
	case ERROR_PROC_NOT_FOUND:
		return CZ_RESULT_NO_FILE;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUTOFMEMORY:
	case ERROR_OUT_OF_STRUCTURES:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_REMOVE_DIRECTORY_W
enum CzResult czWrap_RemoveDirectoryW(LPCWSTR lpPathName)
{
	BOOL r = RemoveDirectoryW(lpPathName);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_EA_NAME:
	case ERROR_MORE_DATA:
	case ERROR_NO_DATA:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_VC_DISCONNECTED:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BAD_ARGUMENTS:
	case ERROR_BAD_DEVICE_PATH:
	case ERROR_BAD_NET_NAME:
	case ERROR_BAD_PATHNAME:
	case ERROR_BUFFER_OVERFLOW:
	case ERROR_DIR_NOT_ROOT:
	case ERROR_DIRECTORY:
	case ERROR_FILENAME_EXCED_RANGE:
	case ERROR_INVALID_FIELD_IN_PARAMETER_LIST:
	case ERROR_INVALID_NAME:
	case ERROR_INVALID_PARAMETER:
	case ERROR_LABEL_TOO_LONG:
	case ERROR_META_EXPANSION_TOO_LONG:
	case ERROR_PATH_NOT_FOUND:
	case ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME:
		return CZ_RESULT_BAD_PATH;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PATH_BUSY:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_BAD_NETPATH:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_FILE_NOT_FOUND:
	case ERROR_MOD_NOT_FOUND:
	case ERROR_NETNAME_DELETED:
	case ERROR_PROC_NOT_FOUND:
		return CZ_RESULT_NO_FILE;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUTOFMEMORY:
	case ERROR_OUT_OF_STRUCTURES:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_CREATE_FILE_MAPPING_W
enum CzResult czWrap_CreateFileMappingW(
	LPHANDLE res,
	HANDLE hFile,
	LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
	DWORD flProtect,
	DWORD dwMaximumSizeHigh,
	DWORD dwMaximumSizeLow,
	LPCWSTR lpName)
{
	HANDLE h = CreateFileMappingW(
		hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

	if CZ_EXPECT (h) {
		*res = h;
		return CZ_RESULT_SUCCESS;
	}

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
	case ERROR_WRITE_PROTECT:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_ALREADY_ASSIGNED:
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BAD_UNIT:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED;
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT;
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_INVALID:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_HANDLE:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_RANGES_PROCESSED:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_OPEN_FAILED:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_MAP_VIEW_OF_FILE
enum CzResult czWrap_MapViewOfFile(
	LPVOID* res,
	HANDLE hFileMappingObject,
	DWORD dwDesiredAccess,
	DWORD dwFileOffsetHigh,
	DWORD dwFileOffsetLow,
	SIZE_T dwNumberOfBytesToMap)
{
	LPVOID p = MapViewOfFile(
		hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);

	if CZ_EXPECT (p) {
		*res = p;
		return CZ_RESULT_SUCCESS;
	}

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ACCESS_DENIED:
	case ERROR_WRITE_PROTECT:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_BAD_UNIT:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_RANGES_PROCESSED:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_OFFSET_ALIGNMENT_VIOLATION:
		return CZ_RESULT_BAD_OFFSET;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_UNMAP_VIEW_OF_FILE
enum CzResult czWrap_UnmapViewOfFile(LPCVOID lpBaseAddress)
{
	BOOL r = UnmapViewOfFile(lpBaseAddress);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_BAD_ARGUMENTS:
	case ERROR_HANDLE_EOF:
	case ERROR_INVALID_ADDRESS:
	case ERROR_INVALID_FIELD_IN_PARAMETER_LIST:
	case ERROR_INVALID_PARAMETER:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_RANGES_PROCESSED:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_FLUSH_VIEW_OF_FILE
enum CzResult czWrap_FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
{
	BOOL r = FlushViewOfFile(lpBaseAddress, dwNumberOfBytesToFlush);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_BAD_ARGUMENTS:
	case ERROR_HANDLE_EOF:
	case ERROR_INVALID_ADDRESS:
	case ERROR_INVALID_FIELD_IN_PARAMETER_LIST:
	case ERROR_INVALID_PARAMETER:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_RANGES_PROCESSED:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_FLUSH_FILE_BUFFERS
enum CzResult czWrap_FlushFileBuffers(HANDLE hFile)
{
	BOOL r = FlushFileBuffers(hFile);
	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif

#if CZ_WRAP_DEVICE_IO_CONTROL
enum CzResult czWrap_DeviceIoControl(
	HANDLE hDevice,
	DWORD dwIoControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned,
	LPOVERLAPPED lpOverlapped)
{
	BOOL r = DeviceIoControl(
		hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned,
		lpOverlapped);

	if CZ_EXPECT (r)
		return CZ_RESULT_SUCCESS;

	DWORD err = GetLastError();
	switch (err) {
	case ERROR_IO_PENDING:
		return CZ_RESULT_SUCCESS;
	case ERROR_ACCESS_DENIED:
	case ERROR_NETWORK_ACCESS_DENIED:
	case ERROR_WRITE_PROTECT:
		return CZ_RESULT_BAD_ACCESS;
	case ERROR_INVALID_ADDRESS:
		return CZ_RESULT_BAD_ADDRESS;
	case ERROR_ALREADY_ASSIGNED:
	case ERROR_BAD_DEV_TYPE:
	case ERROR_BAD_FILE_TYPE:
	case ERROR_BAD_PIPE:
	case ERROR_BROKEN_PIPE:
	case ERROR_COMPRESSED_FILE_NOT_SUPPORTED:
	case ERROR_CURRENT_DIRECTORY:
	case ERROR_DATA_CHECKSUM_ERROR:
	case ERROR_DEV_NOT_EXIST:
	case ERROR_DEVICE_UNREACHABLE:
	case ERROR_DIRECTORY_NOT_SUPPORTED:
	case ERROR_EA_FILE_CORRUPT:
	case ERROR_EA_LIST_INCONSISTENT:
	case ERROR_EA_TABLE_FULL:
	case ERROR_FILE_TOO_LARGE:
	case ERROR_INVALID_DATA:
	case ERROR_INVALID_EA_NAME:
	case ERROR_NO_MORE_ITEMS:
	case ERROR_NOT_ALLOWED_ON_SYSTEM_FILE:
	case ERROR_PIPE_LOCAL:
	case ERROR_RESIDENT_FILE_NOT_SUPPORTED:
	case ERROR_SEEK_ON_DEVICE:
	case ERROR_VIRUS_DELETED:
	case ERROR_VIRUS_INFECTED:
		return CZ_RESULT_BAD_FILE;
	case ERROR_ADAP_HDW_ERR:
	case ERROR_BAD_REM_ADAP:
	case ERROR_CANNOT_MAKE:
	case ERROR_DISK_CHANGE:
	case ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT:
	case ERROR_INTERMIXED_KERNEL_EA_OPERATION:
	case ERROR_INVALID_CAP:
	case ERROR_INVALID_TARGET_HANDLE:
	case ERROR_MAX_THRDS_REACHED:
	case ERROR_NET_WRITE_FAULT:
	case ERROR_NO_MORE_SEARCH_HANDLES:
	case ERROR_NO_RANGES_PROCESSED:
	case ERROR_NO_VOLUME_LABEL:
	case ERROR_NOT_READ_FROM_COPY:
	case ERROR_OPEN_FAILED:
	case ERROR_READ_FAULT:
	case ERROR_SECURITY_STREAM_IS_INCONSISTENT:
	case ERROR_TOO_MANY_CMDS:
	case ERROR_TOO_MANY_NAMES:
	case ERROR_TOO_MANY_SESS:
	case ERROR_TOO_MANY_TCBS:
	case ERROR_UNDEFINED_SCOPE:
	case ERROR_UNEXP_NET_ERR:
	case ERROR_WRITE_FAULT:
	case ERROR_WRONG_DISK:
		return CZ_RESULT_BAD_IO;
	case ERROR_EAS_DIDNT_FIT:
	case ERROR_INSUFFICIENT_BUFFER:
	case ERROR_MORE_DATA:
		return CZ_RESULT_BAD_SIZE;
	case ERROR_BUSY:
	case ERROR_DRIVE_LOCKED:
	case ERROR_FILE_CHECKED_OUT:
	case ERROR_LOCK_VIOLATION:
	case ERROR_LOCKED:
	case ERROR_NETWORK_BUSY:
	case ERROR_NOT_READY:
	case ERROR_OPERATION_IN_PROGRESS:
	case ERROR_PIPE_BUSY:
	case ERROR_REDIR_PAUSED:
	case ERROR_SHARING_PAUSED:
	case ERROR_SHARING_VIOLATION:
		return CZ_RESULT_IN_USE;
	case ERROR_NO_DATA:
	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_REQ_NOT_ACCEP:
	case ERROR_VC_DISCONNECTED:
		return CZ_RESULT_NO_CONNECTION;
	case ERROR_DISK_FULL:
	case ERROR_DISK_RESOURCES_EXHAUSTED:
	case ERROR_DISK_TOO_FRAGMENTED:
	case ERROR_HANDLE_DISK_FULL:
		return CZ_RESULT_NO_DISK;
	case ERROR_DEVICE_NO_RESOURCES:
	case ERROR_NOT_ENOUGH_MEMORY:
	case ERROR_OUT_OF_STRUCTURES:
	case ERROR_OUTOFMEMORY:
		return CZ_RESULT_NO_MEMORY;
	case ERROR_ATOMIC_LOCKS_NOT_SUPPORTED:
	case ERROR_BAD_COMMAND:
	case ERROR_BAD_DRIVER_LEVEL:
	case ERROR_BAD_NET_RESP:
	case ERROR_CALL_NOT_IMPLEMENTED:
	case ERROR_DEVICE_FEATURE_NOT_SUPPORTED:
	case ERROR_DEVICE_SUPPORT_IN_PROGRESS:
	case ERROR_EAS_NOT_SUPPORTED:
	case ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED:
	case ERROR_NOT_REDUNDANT_STORAGE:
	case ERROR_NOT_SUPPORTED:
		return CZ_RESULT_NO_SUPPORT;
	default:
		return CZ_RESULT_INTERNAL_ERROR;
	}
}
#endif
