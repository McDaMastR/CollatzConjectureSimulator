/* 
 * Collatz Conjecture Simulator
 * Copyright (C) 2024  Seth Isaiah McDonald <seth.i.mcdonald@gmail.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#version 460 core
#extension GL_EXT_shader_explicit_arithmetic_types : require

#define UINT_MAX 0xffffffff

layout(local_size_x_id = 0) in;

layout(binding = 0) readonly buffer InBuffer
{
	u64vec2 startingValues[];
};

layout(binding = 1) writeonly buffer OutBuffer
{
	uint16_t stepCounts[];
};

#if INT_SIZE == 128

void main(void)
{
	u64vec2 n = startingValues[gl_GlobalInvocationID.x];
	uint16_t steps = uint16_t(0);

	// Loop until n == 1
	do {
		// 3n + 1
		u64vec2 copy1 = n;
		n <<= 1;
		n += u64vec2(1, copy1.x >> 63) + copy1;
		n.y += uint64_t(copy1.x > n.x);

		// Check if 2^32 | n
		while ((n.x & UINT_MAX) == 0) {
			n = u64vec2((n.x >> 32) + (n.y << 32), n.y >> 32);
			steps += uint16_t(32);
		}

		// Calculate # trailing zero bits (by Sean Eron Anderson: https://graphics.stanford.edu/~seander/bithacks.html)
		uint copy2 = uint(n.x & UINT_MAX);
		uint factorsOf2 = (floatBitsToUint(float(copy2 & -copy2)) >> 23) - 0x7f;

		// n/2 for each factor of 2
		uint64_t copy3 = n.y;
		n >>= factorsOf2;
		n.x += copy3 << (64 - factorsOf2);
		steps += uint16_t(factorsOf2) + uint16_t(1);
	}
	while (n != u64vec2(1, 0));

	stepCounts[gl_GlobalInvocationID.x] = steps;
}

#elif INT_SIZE == 256

void main(void)
{
	u64vec4 n = u64vec4(startingValues[gl_GlobalInvocationID.x], 0, 0);
	uint16_t steps = uint16_t(0);

	// Loop until n == 1
	do {
		// 3n + 1
		u64vec4 copy1 = n;
		n <<= 1;
		n += u64vec4(1, copy1.xyz >> 63) + copy1;
		n.y += uint64_t(copy1.x > n.x);
		n.z += uint64_t(copy1.y > n.y);
		n.w += uint64_t(copy1.z > n.z);

		// Check if 2^32 | n
		while ((n.x & UINT_MAX) == 0) {
			n = u64vec4((n.xyz >> 32) + (n.yzw << 32), n.w >> 32);
			steps += uint16_t(32);
		}

		// Calculate # trailing zero bits (by Sean Eron Anderson: https://graphics.stanford.edu/~seander/bithacks.html)
		uint copy2 = uint(n.x & UINT_MAX);
		uint factorsOf2 = (floatBitsToUint(float(copy2 & -copy2)) >> 23) - 0x7f;

		// n/2 for each factor of 2
		u64vec3 copy3 = n.yzw;
		n >>= factorsOf2;
		n.xyz += copy3 << (64 - factorsOf2);
		steps += uint16_t(factorsOf2) + uint16_t(1);
	}
	while (n != u64vec4(1, 0, 0, 0));

	stepCounts[gl_GlobalInvocationID.x] = steps;
}

#endif
