/* 
 * Collatz Conjecture Simulator
 * Copyright (C) 2024  Seth Isaiah McDonald <seth.i.mcdonald@gmail.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#version 460 core
#extension GL_EXT_shader_explicit_arithmetic_types : require

layout(local_size_x_id = 0) in;

layout(binding = 0) readonly buffer InBuffer
{
	uvec4 startingValues[];
};

layout(binding = 1) writeonly buffer OutBuffer
{
	uint16_t stepCounts[];
};

#if INT_SIZE == 128

void main(void)
{
	uvec4 n = startingValues[gl_GlobalInvocationID.x];
	uint16_t steps = uint16_t(0);

	// Loop until n == 1
	do {
		// 3n + 1
		uvec4 copy = n;
		n <<= 1U;
		n += uvec4(1, copy.xyz >> 31U) + copy;
		n.y += uint(copy.x > n.x);
		n.z += uint(copy.y > n.y);
		n.w += uint(copy.z > n.z);

		// Check if 2^32 divides n
		while (n.x == 0U) {
			n = uvec4(n.yzw, 0);
			steps += uint16_t(32);
		}

		// Calculate # trailing zero bits (by Sean Eron Anderson: https://graphics.stanford.edu/~seander/bithacks.html)
		uint factorsOf2 = (floatBitsToUint(float(n.x & -n.x)) >> 23U) - 0x7fU;

		// n/2 for each factor of 2
		copy = uvec4(n.yzw, 0);
		n >>= factorsOf2;
		n += copy << (32U - factorsOf2);
		steps += uint16_t(factorsOf2) + uint16_t(1);
	}
	while (n != uvec4(1, 0, 0, 0));

	stepCounts[gl_GlobalInvocationID.x] = steps;
}

#elif INT_SIZE == 256

void main(void)
{
	uvec4 n[] = uvec4[](startingValues[gl_GlobalInvocationID.x], uvec4(0));
	uint16_t steps = uint16_t(0);

	// Loop until n == 1
	do {
		// 3n + 1
		uvec4 copy[] = n;
		n[0] <<= 1U;
		n[1] <<= 1U;
		n[0] += uvec4(1,                copy[0].xyz >> 31U) + copy[0];
		n[1] += uvec4(copy[0].w >> 31U, copy[1].xyz >> 31U) + copy[1];
		n[0].y += uint(copy[0].x > n[0].x);
		n[0].z += uint(copy[0].y > n[0].y);
		n[0].w += uint(copy[0].z > n[0].z);
		n[1].x += uint(copy[0].w > n[0].w);
		n[1].y += uint(copy[1].x > n[1].x);
		n[1].z += uint(copy[1].y > n[1].y);
		n[1].w += uint(copy[1].z > n[1].z);

		// Check if 2^32 divides n
		while (n[0].x == 0U) {
			n[0] = uvec4(n[0].yzw, n[1].x);
			n[1] = uvec4(n[1].yzw, 0);
			steps += uint16_t(32);
		}

		// Calculate # trailing zero bits (by Sean Eron Anderson: https://graphics.stanford.edu/~seander/bithacks.html)
		uint factorsOf2 = (floatBitsToUint(float(n[0].x & -n[0].x)) >> 23U) - 0x7fU;

		// n/2 for each factor of 2
		copy = n;
		n[0] >>= factorsOf2;
		n[1] >>= factorsOf2;
		n[0]     += uvec4(copy[0].yzw, copy[1].x) << (32U - factorsOf2);
		n[1].xyz += copy[1].yzw                   << (32U - factorsOf2);
		steps += uint16_t(factorsOf2) + uint16_t(1);
	}
	while (n != uvec4[](uvec4(1, 0, 0, 0), uvec4(0)));

	stepCounts[gl_GlobalInvocationID.x] = steps;
}

#endif
