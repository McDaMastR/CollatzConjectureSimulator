/* 
 * Copyright (C) 2024  Seth McDonald <seth.i.mcdonald@gmail.com>
 * 
 * This file is part of Collatz Conjecture Simulator.
 * 
 * Collatz Conjecture Simulator is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 * 
 * Collatz Conjecture Simulator is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with Collatz Conjecture
 * Simulator. If not, see <https://www.gnu.org/licenses/>.
 */

#version 460 core
#extension GL_EXT_control_flow_attributes : require
#extension GL_EXT_shader_explicit_arithmetic_types : require


#define ATTR_UNROLL [[unroll]]

#if SPV_VER >= 14
	#define ATTR_MIN(min) [[min_iterations(min)]]
	#define ATTR_MAX(max) [[max_iterations(max)]]
	#define ATTR_MINMAX(min, max) [[min_iterations(min), max_iterations(max)]]
#else
	#define ATTR_MIN(min)
	#define ATTR_MAX(max)
	#define ATTR_MINMAX(min, max)
#endif

#if INT16
	#define COUNT_TYPE  uint16_t
	#define TO_COUNT(x) uint16_t(x)
#else
	#define COUNT_TYPE  lowp uint
	#define TO_COUNT(x) uint(x)
#endif

#if ITER_SIZE == 128
	#if INT64
		#define VALUE_TYPE u64vec2
		#define VALUE_1    u64vec2(1, 0)
	#else
		#define VALUE_TYPE uvec4
		#define VALUE_1    uvec4(1, 0, 0, 0)
	#endif
#elif ITER_SIZE == 256
	#if INT64
		#define VALUE_TYPE u64vec4
		#define VALUE_1    u64vec4(1, 0, 0, 0)
	#else
		#define VALUE_TYPE uvec4[2]
		#define VALUE_1    uvec4[](uvec4(1, 0, 0, 0), uvec4(0))
	#endif
#endif


layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;
uint index = gl_GlobalInvocationID.x;

layout(set = 0, binding = 0, std430) restrict readonly buffer InBuffer32
{
	uvec4 startingValues[];
} inBuffer32;

layout(set = 0, binding = 0, std430) restrict readonly buffer InBuffer64
{
	u64vec2 startingValues[];
} inBuffer64;

layout(set = 0, binding = 1, std430) restrict writeonly buffer OutBuffer16
{
	uint16_t stepCounts[];
} outBuffer16;

layout(set = 0, binding = 1, std430) restrict writeonly buffer OutBuffer32
{
	uint stepCounts[];
} outBuffer32;


// Return whether n is even
bool iseven_128_32(in uvec4 n)
{
	return (n.x & 1) == 0;
}

bool iseven_128_64(in u64vec2 n)
{
	return (n.x & 1) == 0;
}

bool iseven_256_32(in uvec4[2] n)
{
	return (n[0].x & 1) == 0;
}

bool iseven_256_64(in u64vec4 n)
{
	return (n.x & 1) == 0;
}

#if ITER_SIZE == 128
	#if INT64
		#define iseven(n) iseven_128_64(n)
	#else
		#define iseven(n) iseven_128_32(n)
	#endif
#elif ITER_SIZE == 256
	#if INT64
		#define iseven(n) iseven_256_64(n)
	#else
		#define iseven(n) iseven_256_32(n)
	#endif
#endif


// Read starting value from in-buffer
void readin_128_32(out uvec4 n, out COUNT_TYPE steps)
{
	n = inBuffer32.startingValues[index];
	steps = TO_COUNT(0);
}

void readin_128_64(out u64vec2 n, out COUNT_TYPE steps)
{
	n = inBuffer64.startingValues[index];
	steps = TO_COUNT(0);
}

void readin_256_32(out uvec4[2] n, out COUNT_TYPE steps)
{
	n[0] = inBuffer32.startingValues[index];
	n[1] = uvec4(0);
	steps = TO_COUNT(0);
}

void readin_256_64(out u64vec4 n, out COUNT_TYPE steps)
{
	n.xy = inBuffer64.startingValues[index];
	n.zw = u64vec2(0);
	steps = TO_COUNT(0);
}

#if ITER_SIZE == 128
	#if INT64
		#define readin(n, steps) readin_128_64(n, steps)
	#else
		#define readin(n, steps) readin_128_32(n, steps)
	#endif
#elif ITER_SIZE == 256
	#if INT64
		#define readin(n, steps) readin_256_64(n, steps)
	#else
		#define readin(n, steps) readin_256_32(n, steps)
	#endif
#endif


// Write step count to out-buffer
void writeout_16(in COUNT_TYPE steps)
{
	outBuffer16.stepCounts[index] = uint16_t(steps);
}

void writeout_32(in COUNT_TYPE steps)
{
	uint outindex = index / 2;
	bool even = (index & 1) == 0;

	atomicAnd(outBuffer32.stepCounts[outindex], even ? 0xFFFF0000U : 0x0000FFFFU);
	atomicOr(outBuffer32.stepCounts[outindex], uint(steps) << (even ? 0U : 16U));
}

#if STO16
	#define writeout(steps) writeout_16(steps)
#else
	#define writeout(steps) writeout_32(steps)
#endif


// 3n + 1
void up_128_32(inout uvec4 n, inout COUNT_TYPE steps)
{
	uvec4 left;
	uvec4 right;
	uvec4 _2n_1;

	steps += TO_COUNT(1);

	left  = n << 1U;
	right = n >> 31U;

	_2n_1 = left | uvec4(1, right.xyz);

	n += _2n_1;

	ATTR_UNROLL
	for (uint i = 0; i < n.length() - 1; i++) {
		lowp uint carry = uint(_2n_1[i] > n[i]);
		n[i + 1] += carry;
	}
}

void up_128_64(inout u64vec2 n, inout COUNT_TYPE steps)
{
	u64vec2 left;
	u64vec2 right;
	u64vec2 _2n_1;

	steps += TO_COUNT(1);

	left  = n << 1U;
	right = n >> 63U;

	_2n_1 = left | u64vec2(1, right.x);

	n += _2n_1;

	ATTR_UNROLL
	for (uint i = 0; i < n.length() - 1; i++) {
		uint64_t carry = uint64_t(_2n_1[i] > n[i]);
		n[i + 1] += carry;
	}
}

void up_256_32(inout uvec4[2] n, inout COUNT_TYPE steps)
{
	uvec4[2] left;
	uvec4[2] right;
	uvec4[2] _2n_1;

	steps += TO_COUNT(1);

	left[0]  = n[0] << 1U;
	left[1]  = n[1] << 1U;
	right[0] = n[0] >> 31U;
	right[1] = n[1] >> 31U;

	_2n_1[0] = left[0] | uvec4(1,          right[0].xyz);
	_2n_1[1] = left[1] | uvec4(right[0].w, right[1].xyz);

	n[0] += _2n_1[0];
	n[1] += _2n_1[1];

	ATTR_UNROLL
	for (uint i = 0; i < n.length() * n[0].length() - 1; i++) {
		lowp uint carry = uint(_2n_1[i / 4][i % 4] > n[i / 4][i % 4]);
		n[(i + 1) / 4][(i + 1) % 4] += carry;
	}
}

void up_256_64(inout u64vec4 n, inout COUNT_TYPE steps)
{
	u64vec4 left;
	u64vec4 right;
	u64vec4 _2n_1;

	steps += TO_COUNT(1);

	left  = n << 1U;
	right = n >> 63U;

	_2n_1 = left | u64vec4(1, right.xyz);

	n += _2n_1;

	ATTR_UNROLL
	for (uint i = 0; i < n.length() - 1; i++) {
		uint64_t carry = uint64_t(_2n_1[i] > n[i]);
		n[i + 1] += carry;
	}
}

#if ITER_SIZE == 128
	#if INT64
		#define up(n, steps) up_128_64(n, steps)
	#else
		#define up(n, steps) up_128_32(n, steps)
	#endif
#elif ITER_SIZE == 256
	#if INT64
		#define up(n, steps) up_256_64(n, steps)
	#else
		#define up(n, steps) up_256_32(n, steps)
	#endif
#endif


// n/2 for each factor of 2 (up to 31 factors of 2)
void down_128_32(inout uvec4 n, inout COUNT_TYPE steps)
{
	uint x = n.x;
	lowp uint factors = findLSB(x) & 31U;
	steps += TO_COUNT(factors);

	uvec4 right = n >> factors;
	uvec4 left  = n << (32 - factors);

	n = right | uvec4(left.yzw, 0);
}

void down_128_64(inout u64vec2 n, inout COUNT_TYPE steps)
{
	uint x = uint(n.x);
	lowp uint factors = findLSB(x) & 31U; // findLSB (GLSL) => FindILsb (SPIR-V); SPIR-V Extended Instructions for GLSL (ver 1.00, rev 14): "[FindILsb] is currently limited to 32-bit width components."
	steps += TO_COUNT(factors);

	u64vec2 right = n >> factors;
	u64vec2 left  = n << (64 - factors);

	n = right | u64vec2(left.y, 0);
}

void down_256_32(inout uvec4[2] n, inout COUNT_TYPE steps)
{
	uint x = n[0].x;
	lowp uint factors = findLSB(x) & 31U;
	steps += TO_COUNT(factors);

	uvec4[2] right = uvec4[](n[0] >> factors,        n[1] >> factors);
	uvec4[2] left  = uvec4[](n[0] << (32 - factors), n[1] << (32 - factors));

	n[0] = right[0] | uvec4(left[0].yzw, left[1].x);
	n[1] = right[1] | uvec4(left[1].yzw, 0);
}

void down_256_64(inout u64vec4 n, inout COUNT_TYPE steps)
{
	uint x = uint(n.x);
	lowp uint factors = findLSB(x) & 31U; // findLSB (GLSL) => FindILsb (SPIR-V); SPIR-V Extended Instructions for GLSL (ver 1.00, rev 14): "[FindILsb] is currently limited to 32-bit width components."
	steps += TO_COUNT(factors);

	u64vec4 right = n >> factors;
	u64vec4 left  = n << (64 - factors);

	n = right | u64vec4(left.yzw, 0);
}

#if ITER_SIZE == 128
	#if INT64
		#define down(n, steps) down_128_64(n, steps)
	#else
		#define down(n, steps) down_128_32(n, steps)
	#endif
#elif ITER_SIZE == 256
	#if INT64
		#define down(n, steps) down_256_64(n, steps)
	#else
		#define down(n, steps) down_256_32(n, steps)
	#endif
#endif


// Entry point
void main(void)
{
	VALUE_TYPE n;
	COUNT_TYPE steps;
	readin(n, steps);

	ATTR_MIN(2)
	do {
		up(n, steps);

		ATTR_MINMAX(1, n.length())
		do {
			down(n, steps);
		}
		while (iseven(n));
	}
	while (n != VALUE_1);

	writeout(steps);
}
